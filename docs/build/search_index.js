var documenterSearchIndex = {"docs":
[{"location":"distributions/#Recurrence-Motifs-Probability-Distributions","page":"Distributions","title":"Recurrence Motifs Probability Distributions","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"RMA.jl aims to be a user-friendly library with powerful capabilities. It can be used through simple function calls or more advanced configurations that offer greater control. We'll begin with the simpler usage, explaining its arguments and settings, and gradually move toward more complex configurations throughout this discussion.","category":"page"},{"location":"distributions/#One-dimensional-data","page":"Distributions","title":"One-dimensional data","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"This section presents a run similar to the one shown on the quick start page, but with a more detailed explanation. For one-dimensional problems, such as the logistic map or the Bernoulli shift, you can use a vector of positions along the trajectory as input. To illustrate this, let's consider a uniform distribution:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\ndata = rand(Uniform(0, 1), 3000)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Computing the recurrence motif distribution is straightforward once the threshold and n (motif size) parameters are defined. A good value for threshold can be estimated using the find_parameters function, which we recommend using in most cases.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using RMA\nth, s = find_parameters(data, 3)\ndist = distribution(data, th, 3)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"warning: Warning\nWe do not recommend using find_parameters inside a loop, as it needs to compute several distributions to find the threshold value that maximizes recurrence entropy, which can significantly reduce the library's performance. For this reason, we have not created an overload of the distribution function that automatically calculates the threshold. Instead, we suggest using an average threshold value computed from a few representative snippets of your dataset using the find_parameters function.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The distribution function includes several keyword arguments for configuration. Before moving on to the next section, we will discuss these arguments, as they apply to every call of the distribution function.","category":"page"},{"location":"distributions/#Motif-constrained-shape","page":"Distributions","title":"Motif constrained shape","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"There are variations in motif constraint shapes proposed in the literature, such as the triangular motif. Supporting these shape generalizations is one of the goals of RMA.jl, and it is also a computational challenge. Adapting the conversion of motifs with a generic shape from a binary structure to a decimal value can be a very complex problem, and to support this in the library, we need to adapt the pipeline that converts a motif for each specific shape.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Currently, RMA.jl supports five shapes: square, triangle, diagonal, line, and pair. The way the library converts these motifs constrained shapes to decimal values is detailed on the motifs page. You can change the shape using the kword shape, which can be set to :square, :triangle, :diagonal, :line, or :pair. By default, the library uses :square as the default shape.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 3; shape = :triangle)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"note: Note\nThe shape :pair doesn't require a value of n, since it always uses n=2. However, it is still necessary to informe a value to this parameter, that will be interpreted as the separation between two points in a diagonal.dist = distribution(data, th, 6; shape = :pair)","category":"page"},{"location":"distributions/#Motifs-sampling","page":"Distributions","title":"Motifs sampling","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The sampling mode defines how RMA.jl selects motifs from a recurrence space. Currently, the library supports four sampling modes: full, random, columnwise and triangle up. You can learn more about them on the motifs page, where we discuss how each mode works. The sampling mode can be configured using the keyword argument sampling_mode, which can be set to :full, :random, :columnwise, or :triangleup. By default, the library uses :random as the default sampling mode.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 3; sampling_mode = :full)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"compat: Compat\nNot all sampling modes are compatible with certain motif constrained shapes, and the following table illustrates the compatibility between them. :full :random :columnwise :triangleup\n:square checkmark checkmark checkmark checkmark\n:triangle checkmark checkmark  \n:diagonal  checkmark  \n:time  checkmark  \n:pair  checkmark checkmark ","category":"page"},{"location":"distributions/#Run-mode","page":"Distributions","title":"Run mode","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"RMA.jl has two run modes that results in a different output type. The run mode :vect allocates all required memory in beginning of the process, and return the distribution as a vector. This is the default configuration of the library for n  6.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 4; run_mode = :vect)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The run mode :dict uses dictionaries to allocate memory just when needed. The total allocation of dictionary mode can be greater than when using vectors, but the real memory allocation is smaller.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 4; run_mode = :dict)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"compat: Compat\nIt is important to note that the shapes :diagonal, :line, and :pair are not ocmpatible with run mode :dict. Additionally, the sampling mode :columnwise returns a matrix in which each column represents a probability distribution for a specif time value.dist = distribution(data, th, 2; sampling_mode = :columnwise)","category":"page"},{"location":"distributions/#Number-of-samples","page":"Distributions","title":"Number of samples","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"With exception of the sampling mode :full, all sampling modes take motifs randomly in a recurrence space. The kword num_samples defines the number of samples that will be used by the library, it can be either an integer value that specifies the exact number, or a decimal value interpreted as the percentage of samples taken from the entire available population. By default, RMA.jl uses 5.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 3; num_samples = 0.1)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 3; num_samples = 50000)","category":"page"},{"location":"distributions/#Threads","page":"Distributions","title":"Threads","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"RMA.jl is highly compatible with CPU asyncronous jobs, that can increase significantly the computational performance of the library. The kword threads defines if the library will use threads or not, being true by default. The number of threads used is equal to the number of threads available to Julia, being it configured by the environment variable JULIA_NUM_THREADS, or by the running argument --threads T in Julia initiation: For example, using julia --threads 8.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using BenchmarkTools\n@benchmark distribution(data, th, 4; sampling_mode = :full, threads = false)\n@benchmark distribution(data, th, 4; sampling_mode = :full, threads = true)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"warning: Warning\nRMA.jl allocates memory for each thread, so how many threads you use, more memory the library will allocate. It is done to increase the performance, and avoid the memory concurrency.","category":"page"},{"location":"distributions/#Metrics","page":"Distributions","title":"Metrics","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"RMA.jl uses the library Distances.jl to simplify the configuration of metrics, and increase the computation performance. With it, modify the metric is a easy process that can be done with the kword metric.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distances\nmy_metric = KLDivergence()\ndist = distribution(data, th, 2; metric = my_metric)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"warning: Warning\nThe default recurrence functions were configured to metrics with two arguments, like euclidean(x, y), so if you need to use another type of metric, it is needed to define a new recurrence function, see Recurrence functions page to know more about it.","category":"page"},{"location":"distributions/#Recurrence-functions","page":"Distributions","title":"Recurrence functions","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"A recurrence function defines if two points of a trajectory recurr or not, and we describe more about on the Recurrence functions page. Actually the library have two recurrence functions available","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Standard recurrence: R(mathbfx mathbfy)=Theta(varepsilon - mathbfx-mathbfy)\nRecurrence with corridor threshold: R(mathbfx mathbfy)=Theta(mathbfx-mathbfy - varepsilon_min) cdot Theta(varepsilon_max - mathbfx-mathbfy)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"RMA.jl automatically change between them with the type of parameters, so if you use as parameter a Float64, the library will apply the standard recurrence, or, if you use a Tuple, the library will apply the recurrence with corridor threshold.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"dist = distribution(data, th, 2);\ndist = distribution(data, (0.0, th), 2);","category":"page"},{"location":"distributions/#High-dimensionality-data","page":"Distributions","title":"High-dimensionality data","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"If you are working with a dynamical system or a data time serie with two or more dimensions, it is important to note that RMA.jl effectively not works with vectors, but matrices. In this situation, each row of the matrix will represent a coordinate, and each column a set of coordinates along a trajectory. For example, if we want a uniform distribution with three dimension and 3,000 points, we will have something like:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\ndata = rand(Uniform(0, 1), 3, 3000)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"This format of data is effectvely what the library uses. In the case of previuous section when we are working with vectors RMA.jl converts it to a matrix 1times 3000, but when we are working which data with a dimensionality different than one, it is necessary to use the proper format.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using RMA\nth, s = find_parameters(data, 3)\ndist = distribution(data, th, 3)","category":"page"},{"location":"distributions/#Continuous-problems","page":"Distributions","title":"Continuous problems","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Work with continuous problems means numeric integrate some differential equations problem and take the numerical values as input to RMA.jl. Thinking in it, we make the library compatible with a powerful tool to solve these problems in Julia: the library DifferentialEquations.jl. The way to apply this kind of data in the library is similar with the other two cases discussed before, as we will demonstrate in this section. ","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"info: Info\nThe code of Lorenz system used in these examples was get from Example 2 of DifferentialEquations.jl documentation","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"function lorenz!(du, u, p, t)\n    du[1] = 10.0 * (u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\n\nusing DifferentialEquations\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 1000.0)\nprob = ODEProblem(lorenz!, u0, tspan)\nsol = solve(prob)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"With the data computed, it is easy to apply to RMA.jl, with a simply memory access given by DifferentialEquations.jl.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using RMA\ndata = sol[:, :]\nth, s = find_parameters(data, 3; threshold_max = 30.0)\ndist = distribution(data, th, 3)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"todo: Todo\nIt is necessary improve the function find_parameters to adjust the threshold_max based in the data distribution.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"warning: Warning\nAlthough it is possible to compute the distribution as demonstrated above, we strongly advise against doing so in this way.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"We recommend you to apply a transient into your data and take a correct time resolution while do the process of discretization, it need to be done to maximize the information available to analysis. RMA.jl has a utilitary function to help with this process.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"prepared_data = prepare(sol, 0.2; transient = 10000, max_length = 1000)\nth, s = find_parameters(prepared_data, 3; threshold_max = 30.0)\ndist = distribution(data, th, 3)","category":"page"},{"location":"distributions/#Spatial-data","page":"Distributions","title":"Spatial data","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"RMA.jl is compatible with the generalised recurrence plot analysis for spatial data proposed by Marwan, Kurths and Saparin at 2006. It allow the library to calculate a probability distribution of motifs in a tensorial recurrence space, for example, to images the recurrence space have four dimensions.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"todo: Todo\nThis is a open research field, so we just will explain how to use the library to estimate it, but we don't recommend you to apply it, intead you are a researcher working with it 😉.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The application of RMA.jl to spatial data is very similar to the others presented before, but the input format is more complex. Instead to matrices we need to use abstract arrays with dimension D, where the first dimension will be interpreted as a coordinate dimension (such as for high-dimensionaly data), and rest of the dimensions will be the spatial data dimensionality. To illustrate it, let an image with RGB. It can be represented as an abstract array with 3 dimensions, where the first dimension will have a length 3, being each element a color value (red, blue and green), and the others two dimensions are relative to each pixel that compose the image. We will demonstrate it using a uniform distribution, where each position can be interpreted as a pixel with three colors for a image 100x100.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\ndata = rand(Uniform(0, 1), 3, 100, 100)","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"When we work with spatial data is necessarity to use the complete structure of distribution function, defining a vector structure where each value represents the length of a motif constrained side. For example, to a square tensorial motif constrained with side 2, we can use:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using RMA\ndist = distribution(data, data, 0.5, [2, 2, 2, 2])","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"warning: Warning\nThe find_parameters function is not compatible with spatial data.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"compat: Compat\nIt is important to note that this functionality is only available to motif shapes :square, :diagonal, :line and :pair, for :random sampling mode.","category":"page"},{"location":"rqa/#Recurrence-Quantification-Analysis","page":"RQA","title":"Recurrence Quantification Analysis","text":"","category":"section"},{"location":"rqa/","page":"RQA","title":"RQA","text":"The recurrence microstate analysis allows us to estimate values of tipical RQA measures, such as determinism and laminarity, with a good precision, and define some novels quantifier. We will demonstate in this page how compute these quantifiers using a uniform distribution as input.","category":"page"},{"location":"rqa/","page":"RQA","title":"RQA","text":"using RMA, Distributions\ndata = rand(Uniform(0, 1), 3000)","category":"page"},{"location":"rqa/#Recurrence-Entropy","page":"RQA","title":"Recurrence Entropy","text":"","category":"section"},{"location":"rqa/#Recurrence-Rate","page":"RQA","title":"Recurrence Rate","text":"","category":"section"},{"location":"rqa/#Determinism","page":"RQA","title":"Determinism","text":"","category":"section"},{"location":"rqa/#Laminarity","page":"RQA","title":"Laminarity","text":"","category":"section"},{"location":"bib/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bib/","page":"Bibliography","title":"Bibliography","text":"[]","category":"page"},{"location":"theory/#A-Brief-Theoretical-Review","page":"Theoretical Overview","title":"A Brief Theoretical Review","text":"","category":"section"},{"location":"theory/","page":"Theoretical Overview","title":"Theoretical Overview","text":"We do here a brief review about the recurrence field. If you are new in this area, we sincerelly expects that this review helps you 😄.","category":"page"},{"location":"theory/","page":"Theoretical Overview","title":"Theoretical Overview","text":"info: Info\nThis section wasn't written yet.","category":"page"},{"location":"theory/#Recurrence-Plots","page":"Theoretical Overview","title":"Recurrence Plots","text":"","category":"section"},{"location":"theory/#Recurrence-Quantification-Analysis","page":"Theoretical Overview","title":"Recurrence Quantification Analysis","text":"","category":"section"},{"location":"theory/#Recurrence-Microstates-Analysis","page":"Theoretical Overview","title":"Recurrence Microstates Analysis","text":"","category":"section"},{"location":"theory/#Computing-Motifs","page":"Theoretical Overview","title":"Computing Motifs","text":"","category":"section"},{"location":"theory/#Estimating-RQA","page":"Theoretical Overview","title":"Estimating RQA","text":"","category":"section"},{"location":"quickstart/#Recurrence-Motifs-Distributions-in-One-Minute","page":"Quick start","title":"Recurrence Motifs Distributions in One Minute","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The following code is an example of how to use RMA.jl to compute the motif distribution of a uniform distribution. Try pasting it into the REPL prompt 😉.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"##  Install everything that we need\nusing Pkg; Pkg.add(\"Distributions\"); Pkg.add(url=\"https://github.com/DynamicsUFPR/RMA.jl\")\nusing Distributions     #   For generate our uniform distribution\nusing RMA               #   !! Import RMA.jl\n\n##  Generate our data\ndata = rand(Uniform(0, 1), 1000)\n\n##  Square motif side\nn = 3\n\n##  Compute the threshold that maximize the recurrence entropy.\nth, s = find_parameters(data, n)\n\n##  Compute the recurrence motif probabilities distribution.\ndist = distribution(data, th, n)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The output will be a set of 512 probabilities. The distribution function samples 5 of all motifs available in the recurrence space, regardless of overlap or repetition. Each value represents the probability of encountering a motif with index I within the recurrence space.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"It is not necessary to compute a Recurrence Plot (RP), as the library calculates the recurrences internally without needing to construct one explicitly.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"note: Note\nIt is important to remember that Julia's indexing starts at 1 instead of 0. Therefore, in the library, we define I = i - 1, where i is the Julia index.","category":"page"},{"location":"quickstart/#Easy-RQA-Estimation","page":"Quick start","title":"Easy RQA Estimation","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"One of the main goals of RMA.jl is to provide high performance when estimating typical RQA quantifiers, such as determinism (DET) and laminarity (LAM). This process is very simple, as you can see in the following code, give it a try 😁.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"entropy = rentropy(dist)        #   Recurrence entropy\nrr = rrate(dist)                #   Recurrence rate\ndet = determinism(rr, dist)     #   Determinism\nlam = laminarity(rr, dist)      #   Laminarity","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"It is also possible to skip computing the recurrence distribution by using an alternative overload of the determinism and laminarity functions.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"det = determinism(data, th)\nlam = laminarity(data, th)","category":"page"},{"location":"#RMA.jl:-an-efficient-library-for-recurrence-microstates-analysis-in-Julia","page":"Welcome","title":"RMA.jl: an efficient library for recurrence microstates analysis in Julia","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"RMA is an advanced approach that generalizes the analysis of recurrence structures by capturing the statistical properties of generic recurrence motifs. RMA.jl is an efficient Julia package for performing RMA, offering support for a wide range of motif shapes, flexible sampling strategies, and comprehensive distribution computation capabilities. Furthermore, RMA.jl features an optimized pipeline for estimating standard RQA quantifiers with significantly reduced memory and computational requirements, making it particularly well-suited for large-scale datasets.","category":"page"},{"location":"#Installation","page":"Welcome","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"Download Julia 1.8 or later, preferably the current stable release. You can add RMA.jl using Julia's package manager. In the Julia prompt, you can use the following code snippets:","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"using Pkg\nPkg.add(url=\"https://github.com/DynamicsUFPR/RMA.jl\")","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"or, in Pkg REPL mode (type ] in Julia prompt) write:","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"add https://github.com/DynamicsUFPR/RMA.jl","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"todo: GitHub\nRMA.jl is an open-source library available at GitHub repository DynamicsUFPR/RMA.jl. If you have found this library useful, please consider starring it on GitHub 😄.","category":"page"},{"location":"#Learning-RMA","page":"Welcome","title":"Learning RMA","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"If you have worked with recurrence microstates analysis before, the Quick Start page offers a brief guide on how to apply the RMA.jl to time series data and dynamical systems.","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"If you haven't, then you might prefer the Theoretical Overview page, which provides a quick and simple introduction about the recurrence field. The rest of the guide explains how to use the library to compute recurrence motifs probability distributions and calculate common recurrence quantifiers, along with descriptions of all available configuration options. We also include the Utils page, which covers utility functions to simplify the use of RMA.jl, and the Performance Tips page, where we discuss how to improve the library’s performance.","category":"page"}]
}
