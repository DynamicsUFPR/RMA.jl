<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributions · RMA.jl</title><meta name="title" content="Distributions · RMA.jl"/><meta property="og:title" content="Distributions · RMA.jl"/><meta property="twitter:title" content="Distributions · RMA.jl"/><meta name="description" content="Documentation for RMA.jl."/><meta property="og:description" content="Documentation for RMA.jl."/><meta property="twitter:description" content="Documentation for RMA.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">RMA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Welcome</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="quickstart.html">Quick start</a></li><li><a class="tocitem" href="theory.html">Theoretical Overview</a></li><li class="is-active"><a class="tocitem" href="distributions.html">Distributions</a><ul class="internal"><li><a class="tocitem" href="#One-dimensional-data"><span>One-dimensional data</span></a></li><li><a class="tocitem" href="#High-dimensionality-data"><span>High-dimensionality data</span></a></li><li><a class="tocitem" href="#Continuous-problems"><span>Continuous problems</span></a></li><li><a class="tocitem" href="#Spatial-data"><span>Spatial data</span></a></li></ul></li><li><a class="tocitem" href="rqa.html">RQA</a></li><li><a class="tocitem" href="utils.html">Utils</a></li><li><a class="tocitem" href="performance.html">Performance Tips</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="api.html">Public API</a></li><li><a class="tocitem" href="motifs.html">Motifs: shapes and sampling</a></li><li><a class="tocitem" href="recurrence.html">Recurrence functions</a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li><li><a class="tocitem" href="bib.html">Bibliography</a></li><li><a class="tocitem" href="dev.html">Developers and Researchers</a></li><li><a class="tocitem" href="release_notes.html">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href="distributions.html">Distributions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="distributions.html">Distributions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DynamicsUFPR/RMA.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DynamicsUFPR/RMA.jl/blob/main/docs/src/distributions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Recurrence-Motifs-Probability-Distributions"><a class="docs-heading-anchor" href="#Recurrence-Motifs-Probability-Distributions">Recurrence Motifs Probability Distributions</a><a id="Recurrence-Motifs-Probability-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Motifs-Probability-Distributions" title="Permalink"></a></h1><p><code>RMA.jl</code> aims to be a user-friendly library with powerful capabilities. It can be used through simple function calls or more advanced configurations that offer greater control. We&#39;ll begin with the simpler usage, explaining its arguments and settings, and gradually move toward more complex configurations throughout this discussion.</p><h2 id="One-dimensional-data"><a class="docs-heading-anchor" href="#One-dimensional-data">One-dimensional data</a><a id="One-dimensional-data-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-data" title="Permalink"></a></h2><p>This section presents a run similar to the one shown on the <a href="quickstart.html">quick start</a> page, but with a more detailed explanation. For one-dimensional problems, such as the logistic map or the Bernoulli shift, you can use a vector of positions along the trajectory as input. To illustrate this, let&#39;s consider a uniform distribution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = rand(Uniform(0, 1), 3000)</code><code class="nohighlight hljs ansi" style="display:block;">3000-element Vector{Float64}:
 0.007957976896573626
 0.1780485275217205
 0.8154871616892072
 0.557628120781558
 0.0963918408041311
 0.5161613051957032
 0.8318590704534481
 0.010111979227456214
 0.7921210366576847
 0.5731478178470534
 ⋮
 0.6055464946828484
 0.9819130891485821
 0.09869515105755289
 0.8657716703432786
 0.13214278824729064
 0.927431330049017
 0.16890868206844134
 0.5620242157091067
 0.41255117201750147</code></pre><p>Computing the recurrence motif distribution is straightforward once the <code>threshold</code> and <code>n</code> (motif size) parameters are defined. A good value for <code>threshold</code> can be estimated using the <code>find_parameters</code> function, which we recommend using in most cases.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RMA</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; th, s = find_parameters(data, 3)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2534908700322234, 5.710447146559064)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.02272808188696039
 0.003736092567868269
 0.003647085002225189
 0.004072096128170895
 0.003647085002225189
 0.003923008455718736
 0.003891855807743658
 0.013161993769470404
 0.003718291054739653
 0.004005340453938585
 ⋮
 0.0014063195371606587
 0.009287939474855362
 0.0012794837561192702
 0.001275033377837116
 0.0015198041833555853
 0.0012883845126835782
 0.0013796172674677347
 0.0014485981308411215
 0.007901646639964397</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>We do not recommend using <code>find_parameters</code> inside a loop, as it needs to compute several distributions to find the <code>threshold</code> value that maximizes recurrence entropy, which can significantly reduce the library&#39;s performance. For this reason, we have not created an overload of the <code>distribution</code> function that automatically calculates the <code>threshold</code>. Instead, we suggest using an average <code>threshold</code> value computed from a few representative snippets of your dataset using the <code>find_parameters</code> function.</p></div></div><p>The <code>distribution</code> function includes several keyword arguments for configuration. Before moving on to the next section, we will discuss these arguments, as they apply to every call of the distribution function.</p><h3 id="Motif-constrained-shape"><a class="docs-heading-anchor" href="#Motif-constrained-shape">Motif constrained shape</a><a id="Motif-constrained-shape-1"></a><a class="docs-heading-anchor-permalink" href="#Motif-constrained-shape" title="Permalink"></a></h3><p>There are variations in motif constraint shapes proposed in the literature, such as the triangular motif. Supporting these shape generalizations is one of the goals of <code>RMA.jl</code>, and it is also a computational challenge. Adapting the conversion of motifs with a generic shape from a binary structure to a decimal value can be a very complex problem, and to support this in the library, we need to adapt the pipeline that converts a motif for each specific shape.</p><p>Currently, <code>RMA.jl</code> supports five shapes: square, triangle, diagonal, line, and pair. The way the library converts these motifs constrained shapes to decimal values is detailed on the <a href="motifs.html">motifs</a> page. You can change the shape using the <strong>kword</strong> <code>shape</code>, which can be set to <code>:square</code>, <code>:triangle</code>, <code>:diagonal</code>, <code>:line</code>, or <code>:pair</code>. By default, the library uses <code>:square</code> as the default shape.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3; shape = :triangle)</code><code class="nohighlight hljs ansi" style="display:block;">64-element Vector{Float64}:
 0.04379172229639519
 0.031444147752558965
 0.017999554962171784
 0.01465954606141522
 0.016372941700044503
 0.01319537160658656
 0.02414997774810859
 0.021188251001335114
 0.018813974187805962
 0.01306186025812194
 ⋮
 0.006404094348019582
 0.02244770805518469
 0.015031152647975077
 0.006448598130841122
 0.0052113929684023145
 0.007013796172674678
 0.005774365821094793
 0.016795727636849132
 0.015625278148642636</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The shape <code>:pair</code> doesn&#39;t require a value of <code>n</code>, since it always uses <code>n=2</code>. However, it is still necessary to informe a value to this parameter, that will be interpreted as the separation between two points in a diagonal.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 6; shape = :pair)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.3128042077944085
 0.246510041226218
 0.2459905329085108
 0.1946952180708627</code></pre></div></div><h3 id="Motifs-sampling"><a class="docs-heading-anchor" href="#Motifs-sampling">Motifs sampling</a><a id="Motifs-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Motifs-sampling" title="Permalink"></a></h3><p>The sampling mode defines how <code>RMA.jl</code> selects motifs from a recurrence space. Currently, the library supports four sampling modes: full, random, columnwise and triangle up. You can learn more about them on the <a href="motifs.html">motifs</a> page, where we discuss how each mode works. The sampling mode can be configured using the keyword argument <code>sampling_mode</code>, which can be set to <code>:full</code>, <code>:random</code>, <code>:columnwise</code>, or <code>:triangleup</code>. By default, the library uses <code>:random</code> as the default sampling mode.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3; sampling_mode = :full)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.022881164716882636
 0.0037011554511991764
 0.003627612982815762
 0.004143077817944896
 0.0036682226665675716
 0.004107252288717273
 0.004026700477658888
 0.013023581208909119
 0.003627612982815762
 0.004143077817944896
 ⋮
 0.001426123085837523
 0.00943335138702653
 0.0012429901010279924
 0.001220404441297534
 0.0014540491971298632
 0.0012399860970244338
 0.001426123085837523
 0.001417444852049465
 0.008017686685497693</code></pre><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>Not all sampling modes are compatible with certain motif constrained shapes, and the following table illustrates the compatibility between them.</p><table><tr><th style="text-align: right"></th><th style="text-align: center"><code>:full</code></th><th style="text-align: center"><code>:random</code></th><th style="text-align: center"><code>:columnwise</code></th><th style="text-align: center"><code>:triangleup</code></th></tr><tr><td style="text-align: right"><code>:square</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td></tr><tr><td style="text-align: right"><code>:triangle</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: right"><code>:diagonal</code></td><td style="text-align: center"></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: right"><code>:time</code></td><td style="text-align: center"></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: right"><code>:pair</code></td><td style="text-align: center"></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"></td></tr></table></div></div><h3 id="Run-mode"><a class="docs-heading-anchor" href="#Run-mode">Run mode</a><a id="Run-mode-1"></a><a class="docs-heading-anchor-permalink" href="#Run-mode" title="Permalink"></a></h3><p><code>RMA.jl</code> has two run modes that results in a different output type. The run mode <code>:vect</code> allocates all required memory in beginning of the process, and return the distribution as a vector. This is the default configuration of the library for <span>$n &lt; 6$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 4; run_mode = :vect)</code><code class="nohighlight hljs ansi" style="display:block;">65536-element Vector{Float64}:
 0.003564907592963705
 0.0003228679581384992
 0.00027833444667112
 0.00025384101536406146
 0.00028501447339122687
 0.00025829436651079936
 0.00023380093520374083
 0.00039189490091293697
 0.00036740146960587844
 0.0002293475840570029
 ⋮
 0.00012024048096192385
 0.00010688042752171008
 4.898686261411712e-5
 4.008016032064128e-5
 8.016032064128256e-5
 5.789356490759296e-5
 8.238699621465152e-5
 0.00010465375194834112
 0.0007726564239590292</code></pre><p>The run mode <code>:dict</code> uses dictionaries to allocate memory just when needed. The total allocation of dictionary mode can be greater than when using vectors, but the real memory allocation is smaller.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 4; run_mode = :dict)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Int64, Float64} with 38649 entries:
  63746 =&gt; 1.11334e-5
  11950 =&gt; 6.68003e-6
  29965 =&gt; 2.22668e-6
  45120 =&gt; 1.55867e-5
  1703  =&gt; 2.22668e-6
  37100 =&gt; 2.22668e-6
  60623 =&gt; 6.01202e-5
  7685  =&gt; 1.11334e-5
  59930 =&gt; 4.45335e-6
  64460 =&gt; 6.68003e-6
  3406  =&gt; 5.56669e-5
  61392 =&gt; 6.68003e-6
  47756 =&gt; 8.9067e-6
  28804 =&gt; 2.22668e-5
  28900 =&gt; 8.9067e-6
  28576 =&gt; 3.11735e-5
  62178 =&gt; 6.68003e-6
  62961 =&gt; 6.23469e-5
  27640 =&gt; 2.22668e-6
  ⋮     =&gt; ⋮</code></pre><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>It is important to note that the shapes <code>:diagonal</code>, <code>:line</code>, and <code>:pair</code> are not ocmpatible with run mode <code>:dict</code>. Additionally, the sampling mode <code>:columnwise</code> returns a matrix in which each column represents a probability distribution for a specif time value.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 2; sampling_mode = :columnwise)</code><code class="nohighlight hljs ansi" style="display:block;">16×2999 Matrix{Float64}:
 0.323333   0.0233333  0.0866667  …  0.19        0.203333    0.0366667
 0.0        0.0766667  0.04          0.0166667   0.02        0.08
 0.0966667  0.0733333  0.0633333     0.0233333   0.02        0.0266667
 0.206667   0.0        0.07          0.21        0.216667    0.00333333
 0.0        0.0533333  0.0433333     0.01        0.01        0.103333
 0.0        0.16       0.0566667  …  0.0         0.0         0.273333
 0.0        0.203333   0.05          0.00333333  0.00333333  0.17
 0.0        0.0        0.0666667     0.02        0.00666667  0.01
 0.0833333  0.03       0.0866667     0.0233333   0.00666667  0.05
 0.0        0.2        0.0566667     0.0         0.00333333  0.143333
 0.0166667  0.18       0.0666667  …  0.0         0.00333333  0.0933333
 0.02       0.0        0.0466667     0.01        0.0133333   0.0
 0.146667   0.0        0.0966667     0.223333    0.22        0.0
 0.0        0.0        0.0533333     0.04        0.0133333   0.00333333
 0.04       0.0        0.0666667     0.0166667   0.01        0.00666667
 0.0666667  0.0        0.05       …  0.213333    0.25        0.0</code></pre></div></div><h3 id="Number-of-samples"><a class="docs-heading-anchor" href="#Number-of-samples">Number of samples</a><a id="Number-of-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Number-of-samples" title="Permalink"></a></h3><p>With exception of the sampling mode <code>:full</code>, all sampling modes take motifs randomly in a recurrence space. The <strong>kword</strong> <code>num_samples</code> defines the number of samples that will be used by the library, it can be either an integer value that specifies the exact number, or a decimal value interpreted as the percentage of samples taken from the entire available population. By default, <code>RMA.jl</code> uses <span>$5\%$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3; num_samples = 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.022850467289719626
 0.003713840676457499
 0.0035714285714285713
 0.004135514018691589
 0.0037394303515798843
 0.004072096128170895
 0.003892968402314197
 0.01300178015131286
 0.0037038273253226523
 0.004094348019581665
 ⋮
 0.0014040943480195817
 0.009596128170894527
 0.0012160658655985758
 0.0011993769470404984
 0.0015109034267912773
 0.001272808188696039
 0.0014997774810858924
 0.0015153538050734312
 0.007991766800178015</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3; num_samples = 50000)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.02342
 0.00338
 0.00364
 0.00422
 0.0036
 0.00416
 0.00412
 0.014
 0.00342
 0.00452
 ⋮
 0.00142
 0.00964
 0.00132
 0.00114
 0.00132
 0.00118
 0.00122
 0.00138
 0.0083</code></pre><h3 id="Threads"><a class="docs-heading-anchor" href="#Threads">Threads</a><a id="Threads-1"></a><a class="docs-heading-anchor-permalink" href="#Threads" title="Permalink"></a></h3><p><code>RMA.jl</code> is highly compatible with CPU asyncronous jobs, that can increase significantly the computational performance of the library. The <strong>kword</strong> <code>threads</code> defines if the library will use threads or not, being <code>true</code> by default. The number of threads used is equal to the number of threads available to Julia, being it configured by the environment variable <code>JULIA_NUM_THREADS</code>, or by the running argument <code>--threads T</code> in Julia initiation: For example, using <code>julia --threads 8</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark distribution(data, th, 4; sampling_mode = :full, threads = false)</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 4 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.507 s</span></span> … <span class="sgr35">  1.548 s</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.527 s              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.527 s</span></span> ± <span class="sgr32">23.415 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  <span class="sgr34">█</span>                           <span class="sgr32"> </span>                          ▁▁ 
  <span class="sgr34">█</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁<span class="sgr32">▁</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██ ▁
  1.51 s<span class="sgr90">         Histogram: frequency by time</span>        1.55 s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">1.02 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">27</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark distribution(data, th, 4; sampling_mode = :full, threads = true)</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 16 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">292.867 ms</span></span> … <span class="sgr35">408.108 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.18% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">324.232 ms               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">329.817 ms</span></span> ± <span class="sgr32"> 33.773 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.04% ± 0.13%

  ▁█ ▁▁  ▁▁   <span class="sgr34">▁</span>       <span class="sgr32">▁</span>  ▁ ▁▁        █        ▁               ▁ 
  ██▁██▁▁██▁▁▁<span class="sgr34">█</span>▁▁▁▁▁▁▁<span class="sgr32">█</span>▁▁█▁██▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  293 ms<span class="sgr90">           Histogram: frequency by time</span>          408 ms <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">5.03 MiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">145</span>.</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>RMA.jl</code> allocates memory for each thread, so how many threads you use, more memory the library will allocate. It is done to increase the performance, and avoid the memory concurrency.</p></div></div><h3 id="Metrics"><a class="docs-heading-anchor" href="#Metrics">Metrics</a><a id="Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics" title="Permalink"></a></h3><p><code>RMA.jl</code> uses the library <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> to simplify the configuration of metrics, and increase the computation performance. With it, modify the metric is a easy process that can be done with the <strong>kword</strong> <code>metric</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distances</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_metric = KLDivergence()</code><code class="nohighlight hljs ansi" style="display:block;">Distances.KLDivergence()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 2; metric = my_metric)</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{Float64}:
 0.07066488770291306
 0.018216588837002445
 0.017954191683344452
 0.07762953079830999
 0.018656882366021792
 0.058189904380698244
 0.0
 0.061547698465643765
 0.018305537024683124
 0.0
 0.05816989103847009
 0.06092283744718701
 0.07745830553702468
 0.062170335779408496
 0.06114076050700467
 0.3389726484322882</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The default recurrence functions were configured to metrics with two arguments, like <code>euclidean(x, y)</code>, so if you need to use another type of metric, it is needed to define a new recurrence function, see <a href="recurrence.html">Recurrence functions</a> page to know more about it.</p></div></div><h3 id="Recurrence-functions"><a class="docs-heading-anchor" href="#Recurrence-functions">Recurrence functions</a><a id="Recurrence-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-functions" title="Permalink"></a></h3><p>A recurrence function defines if two points of a trajectory recurr or not, and we describe more about on the <a href="recurrence.html">Recurrence functions</a> page. Actually the library have two recurrence functions available</p><ol><li>Standard recurrence: <span>$R(\mathbf{x}, \mathbf{y})=\Theta(\varepsilon - \|\mathbf{x}-\mathbf{y}\|)$</span></li><li>Recurrence with corridor threshold: <span>$R(\mathbf{x}, \mathbf{y})=\Theta(\|\mathbf{x}-\mathbf{y}\| - \varepsilon_{min}) \cdot \Theta(\varepsilon_{max} - \|\mathbf{x}-\mathbf{y}\|)$</span></li></ol><p><code>RMA.jl</code> automatically change between them with the type of parameters, so if you use as parameter a <code>Float64</code>, the library will apply the standard recurrence, or, if you use a <code>Tuple</code>, the library will apply the recurrence with corridor threshold.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 2);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, (0.0, th), 2);</code></pre><h2 id="High-dimensionality-data"><a class="docs-heading-anchor" href="#High-dimensionality-data">High-dimensionality data</a><a id="High-dimensionality-data-1"></a><a class="docs-heading-anchor-permalink" href="#High-dimensionality-data" title="Permalink"></a></h2><p>If you are working with a dynamical system or a data time serie with two or more dimensions, it is important to note that <code>RMA.jl</code> effectively not works with vectors, but matrices. In this situation, each row of the matrix will represent a coordinate, and each column a set of coordinates along a trajectory. For example, if we want a uniform distribution with three dimension and 3,000 points, we will have something like:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = rand(Uniform(0, 1), 3, 3000)</code><code class="nohighlight hljs ansi" style="display:block;">3×3000 Matrix{Float64}:
 0.820713  0.0817713  0.940772  0.881523  …  0.480465  0.235759  0.258029
 0.161645  0.880318   0.370216  0.289824     0.897722  0.939766  0.323002
 0.991672  0.701779   0.738895  0.914725     0.148773  0.585181  0.167542</code></pre><p>This format of data is effectvely what the library uses. In the case of previuous section when we are working with vectors <code>RMA.jl</code> converts it to a matrix <span>$1\times 3,000$</span>, but when we are working which data with a dimensionality different than one, it is necessary to use the proper format.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RMA</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; th, s = find_parameters(data, 3)</code><code class="nohighlight hljs ansi" style="display:block;">(0.6562835660580022, 6.133476683114206)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.00956386292834891
 0.0035113484646194927
 0.0036359590565198043
 0.00294392523364486
 0.00335781041388518
 0.0031019136626613264
 0.0029906542056074765
 0.00548064085447263
 0.0035291499777481087
 0.0029394748553627057
 ⋮
 0.0034935469514908767
 0.0055028927458834
 0.0027881619937694703
 0.0030062305295950158
 0.003202047174009791
 0.0026524254561637738
 0.003186470850022252
 0.003219848687138407
 0.009603916332888296</code></pre><h2 id="Continuous-problems"><a class="docs-heading-anchor" href="#Continuous-problems">Continuous problems</a><a id="Continuous-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-problems" title="Permalink"></a></h2><p>Work with continuous problems means numeric integrate some differential equations problem and take the numerical values as input to <code>RMA.jl</code>. Thinking in it, we make the library compatible with a powerful tool to solve these problems in Julia: the library <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a>. The way to apply this kind of data in the library is similar with the other two cases discussed before, as we will demonstrate in this section. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The code of Lorenz system used in these examples was get from Example 2 of <a href="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/">DifferentialEquations.jl documentation</a></p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function lorenz!(du, u, p, t)
           du[1] = 10.0 * (u[2] - u[1])
           du[2] = u[1] * (28.0 - u[3]) - u[2]
           du[3] = u[1] * u[2] - (8 / 3) * u[3]
       end</code><code class="nohighlight hljs ansi" style="display:block;">lorenz! (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DifferentialEquations</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u0 = [1.0; 0.0; 0.0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tspan = (0.0, 1000.0)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 1000.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob = ODEProblem(lorenz!, u0, tspan)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 1000.0)
u0: 3-element Vector{Float64}:
 1.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol = solve(prob)</code><code class="nohighlight hljs ansi" style="display:block;">retcode: Success
Interpolation: 3rd order Hermite
t: 13309-element Vector{Float64}:
    0.0
    3.5678604836301404e-5
    0.0003924646531993154
    0.003262408731175873
    0.009058076622686189
    0.01695647090176743
    0.027689960116420883
    0.041856352219618344
    0.060240411865493296
    0.08368541210909924
    ⋮
  999.4684386984246
  999.5461655578678
  999.6379068125303
  999.7253820792902
  999.811462486767
  999.8851689329069
  999.9428080600619
  999.9973353539323
 1000.0
u: 13309-element Vector{Vector{Float64}}:
 [1.0, 0.0, 0.0]
 [0.9996434557625105, 0.0009988049817849058, 1.781434788799189e-8]
 [0.9961045497425811, 0.010965399721242457, 2.1469553658389193e-6]
 [0.9693591548287857, 0.0897706331002921, 0.00014380191884671585]
 [0.9242043547708632, 0.24228915014052968, 0.0010461625485930237]
 [0.8800455783133068, 0.43873649717821195, 0.003424260078582332]
 [0.8483309823046307, 0.6915629680633586, 0.008487625469885364]
 [0.8495036699348377, 1.0145426764822272, 0.01821209108471829]
 [0.9139069585506618, 1.442559985646147, 0.03669382222358562]
 [1.0888638225734468, 2.0523265829961646, 0.07402573595703686]
 ⋮
 [0.4932515482755346, 0.8715606700919747, 10.516359581195958]
 [0.9404189451381124, 1.7670046363918026, 8.612476815089584]
 [2.1798699336043352, 4.244219726761523, 7.112313060328521]
 [5.047985066511083, 9.898098798343868, 7.577131003969779]
 [11.054231264129331, 20.013355756332004, 15.432985026875338]
 [17.030266923750112, 21.643364279228603, 34.339086610002006]
 [16.197155332736422, 8.52886663217251, 43.855823473225534]
 [10.191550116138744, -2.3118400709623317, 39.71841399721481]
 [9.858747856008915, -2.613711553766342, 39.371604354846596]</code></pre><p>With the data computed, it is easy to apply to <code>RMA.jl</code>, with a simply memory access given by <code>DifferentialEquations.jl</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RMA</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = sol[:, :]</code><code class="nohighlight hljs ansi" style="display:block;">3×13309 Matrix{Float64}:
 1.0  0.999643     0.996105    0.969359     …  16.1972   10.1916    9.85875
 0.0  0.000998805  0.0109654   0.0897706        8.52887  -2.31184  -2.61371
 0.0  1.78143e-8   2.14696e-6  0.000143802     43.8558   39.7184   39.3716</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; th, s = find_parameters(data, 3; threshold_max = 30.0)</code><code class="nohighlight hljs ansi" style="display:block;">(17.593984962406015, 3.3528445994767666)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.19728406250324718
 0.010414610113700177
 0.0004586724904481821
 0.005381862637245968
 0.03093074485882465
 9.250252885423816e-5
 0.008161908113702888
 0.017808148625699304
 0.0004582207076454752
 0.0053553203975869376
 ⋮
 0.0006803849008765942
 0.012382576002291442
 0.017480831985138154
 0.0006158929057901839
 0.02737431063591592
 0.0010078144871384213
 0.0006856933488084003
 0.0023825895557755238
 0.20579632818044927</code></pre><div class="admonition is-todo"><header class="admonition-header">Todo</header><div class="admonition-body"><p>It is necessary improve the function <code>find_parameters</code> to adjust the <code>threshold_max</code> based in the data distribution.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Although it is possible to compute the distribution as demonstrated above, we strongly advise against doing so in this way.</p></div></div><p>We recommend you to apply a transient into your data and take a correct time resolution while do the process of discretization, it need to be done to maximize the information available to analysis. <code>RMA.jl</code> has a utilitary function to help with this process.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; prepared_data = prepare(sol, 0.2; transient = 10000, max_length = 1000)</code><code class="nohighlight hljs ansi" style="display:block;">3×1000 Matrix{Float64}:
 -10.719   -6.7762   -3.09341  -12.7639  …  -2.68218   -7.09519  -10.68
 -15.3216  -1.71365  -4.16461  -17.1177     -2.00772  -11.6349    -3.69038
  23.3945  30.9561   17.7139    27.2908     21.6974    16.2567    36.4084</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; th, s = find_parameters(prepared_data, 3; threshold_max = 30.0)</code><code class="nohighlight hljs ansi" style="display:block;">(16.047261009667025, 5.3763562604373885)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, th, 3)</code><code class="nohighlight hljs ansi" style="display:block;">512-element Vector{Float64}:
 0.24690845028107666
 0.009744277380183812
 0.0005757971820499464
 0.005164781000545302
 0.03602629014485512
 4.980905399843593e-5
 0.009428142363989658
 0.016823713898600965
 0.0005772654761587438
 0.00518725719497997
 ⋮
 0.00042004506081674196
 0.010740684351553884
 0.01683037769494089
 0.0005223738656298553
 0.026497739052963855
 0.0005953367882670199
 0.00042444994314313426
 0.0011923677620441907
 0.1567271814671466</code></pre><h2 id="Spatial-data"><a class="docs-heading-anchor" href="#Spatial-data">Spatial data</a><a id="Spatial-data-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-data" title="Permalink"></a></h2><p><code>RMA.jl</code> is compatible with the generalised recurrence plot analysis for spatial data proposed by Marwan, Kurths and Saparin at 2006. It allow the library to calculate a probability distribution of motifs in a tensorial recurrence space, for example, to images the recurrence space have four dimensions.</p><div class="admonition is-todo"><header class="admonition-header">Todo</header><div class="admonition-body"><p>This is a open research field, so we just will explain how to use the library to estimate it, but we don&#39;t recommend you to apply it, intead you are a researcher working with it 😉.</p></div></div><p>The application of <code>RMA.jl</code> to spatial data is very similar to the others presented before, but the input format is more complex. Instead to matrices we need to use abstract arrays with dimension <span>$D$</span>, where the first dimension will be interpreted as a coordinate dimension (such as for high-dimensionaly data), and rest of the dimensions will be the spatial data dimensionality. To illustrate it, let an image with RGB. It can be represented as an abstract array with 3 dimensions, where the first dimension will have a length 3, being each element a color value (red, blue and green), and the others two dimensions are relative to each pixel that compose the image. We will demonstrate it using a uniform distribution, where each position can be interpreted as a pixel with three colors for a image 100x100.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = rand(Uniform(0, 1), 3, 100, 100)</code><code class="nohighlight hljs ansi" style="display:block;">3×100×100 Array{Float64, 3}:
[:, :, 1] =
 0.994485  0.162122  0.879588  0.32505   …  0.178818  0.341842   0.101931
 0.674363  0.513574  0.791852  0.399098     0.500748  0.0477469  0.293194
 0.751212  0.670501  0.33019   0.426157     0.167016  0.508438   0.565883

[:, :, 2] =
 0.268319  0.315523   0.776939  0.59012   …  0.888243  0.512755  0.0662345
 0.152284  0.0822765  0.689212  0.90853      0.569268  0.355477  0.776888
 0.989236  0.981866   0.756117  0.136374     0.421935  0.775406  0.711664

[:, :, 3] =
 0.452498  0.325973  0.992225  0.809072   …  0.0838237  0.814426  0.0263799
 0.259074  0.770238  0.748301  0.0844037     0.678099   0.876506  0.815616
 0.126535  0.418572  0.301841  0.753476      0.396778   0.203561  0.404671

;;; …

[:, :, 98] =
 0.847944  0.123196   0.230845  0.959058  …  0.924671  0.576265  0.177275
 0.595676  0.276158   0.297467  0.459927     0.420081  0.423519  0.513916
 0.373222  0.0931869  0.659237  0.227026     0.476881  0.552236  0.0215966

[:, :, 99] =
 0.194472  0.553546  0.72717   0.712937   …  0.562914  0.0446768  0.671522
 0.294531  0.549499  0.271769  0.0503816     0.283     0.846917   0.18981
 0.52883   0.24623   0.419149  0.616064      0.136637  0.589078   0.608553

[:, :, 100] =
 0.371935   0.0677617  0.333458  0.720905  …  0.932797    0.819361  0.101234
 0.130284   0.347261   0.321668  0.99671      0.22186     0.649547  0.975036
 0.0287216  0.370252   0.41412   0.920042     0.00305695  0.894304  0.638427</code></pre><p>When we work with spatial data is necessarity to use the complete structure of <code>distribution</code> function, defining a vector structure where each value represents the length of a motif constrained side. For example, to a square tensorial motif constrained with side 2, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RMA</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist = distribution(data, data, 0.5, [2, 2, 2, 2])</code><code class="nohighlight hljs ansi" style="display:block;">65536-element Vector{Float64}:
 0.7851692074503746
 0.004086004938600619
 0.004106617141857763
 0.00035790280201041853
 0.004011051472211002
 0.00032021786474230584
 0.00034895002685832546
 2.8940366189324127e-5
 0.004205722280750701
 0.00037851500526756303
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>find_parameters</code> function is not compatible with spatial data.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>It is important to note that this functionality is only available to motif shapes <code>:square</code>, <code>:diagonal</code>, <code>:line</code> and <code>:pair</code>, for <code>:random</code> sampling mode.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="theory.html">« Theoretical Overview</a><a class="docs-footer-nextpage" href="rqa.html">RQA »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 11 April 2025 17:09">Friday 11 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
